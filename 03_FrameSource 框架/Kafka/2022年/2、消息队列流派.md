Message Queue（MQ）消息队列中间件，很多人说，MQ通过消息的发送和接收分离来实现应用程序的异步和解耦，这个给人的直觉是——MQ是异步的，用来解耦的。但是这只是MQ的效果并不是目的，MQ的真正目的是为了通信，屏蔽底层复杂的通讯协议，定义了一套应用层更简洁的通讯协议。一个分布式系统中两个模块之间通讯，要么是 HTTP，要么是自己开发的 （RPC）TCP，这两种都协议都是原始的协议。HTTP 协议很难实现两端通讯——模块A可以调用B，B也可以主动调用A，如果要做到两端都要背上 WebServer，而且还支持长协议（Http2.0的库根本找不到）。TCP 就更原始了，粘包、心跳、私有协议就很麻烦，MQ 所要做的就是在这些协议纸上构建一个简单的 "协议"——生产者、消费者模型。

### 1、有 Broker

是否有 Broker 完全看这个中间件是否可以流转消息。生产者只需要把消息推送到MQ之后，由MQ自我处理推送到对应的 Topic 这叫 `有 Broker` 的 MQ

#### 重 Topic

整个 broker 是通过 topic 来进行中转的

Kafka、JMS（ActiveMQ）就属于这个流派，生产者会把发送key和数据到 Broker，由 Broker 比较 key 之后决定给哪个消费者，这种模式是我们常见的模式，是我们对 MQ 最多的印象，在这种模式下 topic 往往是一个比较大的概念，甚至一个系统中就有可能只有一个 topic，topic 某种一样上就是一个 queue。

#### 轻 Topic

topic 只是一种中转模式

### 2、无 Broker

直接使用 socket 建立通信

无 Broker 的 MQ 代表是 ZeroMQ ，该作者非常睿智，他非常敏锐的意识到——MQ 是更高级的 Socket，它是解决通讯问题的。所以 ZeroMQ 被设计成了一个 "库" 而不是一个中间件，这种实现也是可以达到——没有 broker 的目的