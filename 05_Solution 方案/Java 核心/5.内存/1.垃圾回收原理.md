> 创建于 2021年6月24日
>
> 作者：[敖丙](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453147788&idx=2&sn=658b962d5e31ed0e3d7c9f33e3fa2e42&scene=21#wechat_redirect)

[toc]



# 垃圾回收原理

## Java虚拟机规范

​		Java虚拟机运行时区分为程序计数器、虚拟机、本地方法栈、堆、方法区，其中，程序计数器、栈、本地栈是线程私有的，不需要管理，所以 GC 只关心 堆和方法区，方法区的回收，往往性价比比较低，因为判断是否可以回收的条件比较苛刻。so GC 重点关注 堆的垃圾回收



## 如何判断能回收♻️

### 1、引用计数法

​		在被引用的时候 计数器加一，当计数器减少为0时，说明没有被人引用了，立刻清理释放内存。

### 2、可达性分析

​		可以理解为标记清除，存在的弊端是，当内存不足的时候，再扫描，原本不富裕的家庭更加艰辛了，这样扫描的时间也会长一点。这种就是攒着，一次性处理。而不论标记清除还是计数，其实都关心引用类型，不是基本类型整型啥的，所以 JVM 还需要判断栈上的数据都是什么类型，这里又分为了 保守GC、半保守GC、准确式GC

### 3、分代收集

​		堆分为新生代、老年代，其中新生代的对象有着朝生夕死的特性，因此GC特别频繁，需要追溯标记的对象也很少，都是直接干掉。如果用标记清除的话，需要对对象处理很多次。因此可以使用标记-复制算法，每次将存活的对象复制到另一个区域，剩下的直接干掉就行了。但是朴素的 标记-复制算法将堆对半分，这样效率很低，只有50%，所以 虚拟机分为了 Eden 区和 两个 survivor，默认比例死 8:1:1 这样能有 90% 的利用率。每次回收将存活对象拷贝到 survivor区就可以了， 这就是 分配担保机制

​		老年代的对象基本上都不是垃圾，追溯标记非常耗时，回收率也比较低，所以安排的少一点，这样一来，新生代回收多、老年代回收少，这样就区分出来了分代收集的特性。（下面讲 标记-清除、复制）

## 标记-清除 &复制

### 1、标记-清除

​		全局遍历从根-》（栈、寄存器、全局变量） tracing 阶段，凡事遇到对象统统标记一遍

开始清理♻️ 把没有标记到到 统统干掉，清理不会移动和整理空间，因此就会有很多空间碎片，这样一来，明明剩余的空间很大，但是能申请到的就是不多。

申请也有门道，需要遍历链表查找合适的内存块，所以会有多个空闲链表的实现，根据内存分块大小组成不同的链表，比如 大的和大的一块，小的和小的一块，这样，申请的效率就会高一点。当然还可以有多个链表，

标记，标记一般都是标记在对象身上，比如放到对象头里，标记容易，修改复制就麻烦了，每次GC都要修改对象，所以有一种“冲天而降的掌法” 位图标记法，其实就是将堆内存某个块用位来标记，就像我们的内存是一页一页的，堆内存可以分为一块一块，而对象就在一块或者多块上，采用 位图标记，不仅可以利用写时复制，清除也更高效，可以更快速的遍历清除对象。但是，不论是标记对象头还是利用位图，碎片问题还是处理不了。

### 2、标记-复制

​		简单粗暴的把活动的内存，一箩筐移到另一个区中，相当紧密，缺点是，效率是50%，因为对半分了。如果存活的对象非常多的话，也会很困难，要挪很多，所以不适用保守型的GC

### 3、标记-整理

​		和标记-复制差不多，区别在于复制算法是分为两个区来回复制，而且整理不分区，直接整理。这种就是不挪到另一个分区了，直接整理到一块，删掉垃圾。

### 4、 跨代引用

​		有了分代收集到基础，我们搞个叫 记忆集 的东西，用来记录跨代之间的引用而避免扫描整体非收集区域。根据记录的精度分为

+ 字长精度，每条记录精确到机器字长
+ 对象精度，每条记录精确到对象
+ 卡精度，每条记录精确到一块内存区域

最常见的是卡精度来实现记忆集，成为卡表，简单的来讲，一处老年代引用了新生代后，吧老年代和新生代都切割成片，新、老一一对应，其中一块脏了，只要处理那一块就行了，这样不用扫描整个老年代，用卡表的话，占用内存少，但相对字长，对象来说精度不准，需要扫描一大片，所以这是一种取舍了。 不过这种将老年代作为根来扫描会有浮动垃圾的情况，因为这个老年代也有可能成为垃圾了，不过这是分代收集必须作出的牺牲

## 总结

关于垃圾回收首先得找出垃圾，而找出垃圾分为两个流派，一个是引用计数，一个是可达性分析。

引用计数垃圾回收的及时，对内存较友好，但是循环引用无法处理。

可达性分析基本上是现代垃圾回收的核心选择，但是由于需要统一回收比较耗时，容易影响应用的正常运行。

所以可达性分析的研究方向就是往如何减少对应用程序运行的影响即减少 STW(stop the world) 的时间。

因此根据对象分代假说研究出了分代收集，根据对象的特性划分了新生代和老年代，采取不同的收集算法，提升回收的效率。

想方设法的拆解 GC 的步骤使得可以与应用线程并发，并且采取并行收集，加快收集速度。

还有往评估的方向的延迟回收或者说回收部分垃圾来减少 STW 的时间。

