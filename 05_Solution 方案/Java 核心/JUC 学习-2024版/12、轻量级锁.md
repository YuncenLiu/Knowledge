## 轻量级锁

主要作用：

多线程竞争，但是任意时刻最多只有一个线程竞争，既不存在锁竞争太过于激烈的情况，也就没有线程阻塞。



轻量锁是为了线程近乎交替执行同步代码块时提高性能。

主要目的：在没有多线程竞争条件下，通过CAS 减少重量级锁使用操作系统互斥产生的性能消耗，说白了 先自旋，不行再升级阻塞。

升级时机：当关闭偏向锁功能或多线程竞争导致偏向锁升级为轻量锁。





1. 假设线程A已经拿到锁，此时线程B又来抢锁，由于该对象的锁已经被A拿到，当前锁已经是偏向锁了。
2. 而线程B在争抢过程中发现 MarkWord 的线程ID不是不是线程B，那么线程B就会进行 CAS 操作希望获得锁。

此时会有2种情况，

1. 获取锁 `成功`，直接替换 MarkWord 中线程ID为 B，重新偏向锁于其他线程，锁仍旧保持偏向锁状态，
2. 获取锁 `失败`，则偏向锁升级为轻量级。此时轻量锁由原本偏向锁持有者持有，线程B继续自旋等待。



#### 轻量锁加锁

JVM会为每个线程在当前线程的栈帧中创建用于存储记录的空间，官方称为 Displace Mark Word，若一个线程获得当前锁时，发现是轻量锁，会把锁的 Mark Word 复制到自己的 Displace Mark Word 里面，然后线程尝试用 CAS 将锁 Mark Word 替换为指向锁记录的指针，如果成功，当前线程获得锁，如果失败，表示 Mark Word 已经被替换成了其他锁记录，说明在其他线程竞争锁，当前锁就尝试使用自旋来获取。



#### 升级重量锁

自适应自旋锁大致原理：线程如果自旋成功了，那下次自旋的最大次数会增加，因为JVM认为既然上次成功了，那么下一次大概率会成功。反之，如果自旋成功很少，就会减少自旋次数，甚至不自旋，避免CPU空转。