## 偏向锁



在实际应用运行中，发现，锁总是在同一个线程持有，很少发生竞争，也就是说，锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。

也这样说非公平锁的特性。



那么只有需要在锁第一次被拥有时记录，记录下偏向线程ID，这样偏向锁就一直持有，如果自始至终使用锁的线程只有1个，很明显偏向锁几乎没有开销，性能极高。

如果不等，表示发生了竞争，就会尝试CAS来替换 MarkWord里的线程ID为新线程ID

竞争成功，为新ID，锁不会升级，仍然为偏向锁

竞争失败，就可能需要升级为轻量锁，才能保证线程间公平竞争



注意：偏向锁只有遇到其他线程尝试竞争时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。



#### 细化说明：

偏向锁的操作不用直接捅到操作系统，不涉及用户到内核转化，不必直接升级为最高级，我们可以以一个 account 对象的 对象头为例

<img src="images/11%E3%80%81%E5%81%8F%E5%90%91%E9%94%81/image-20241206150757608.png" alt="image-20241206150757608" style="zoom: 67%;" />

假设有一个线程执行到了 synchronized 代码，JVM 使用 CAS 操作把线程指针 ID 记录到 MarkWord 中，并修改偏向标志，标识当前线程就获得该锁，锁对象变成偏向锁，字面意思是 偏向于第一个获得它的线程，执行完同步代码块之后，线程并不会主动释放偏向锁

<img src="images/11%E3%80%81%E5%81%8F%E5%90%91%E9%94%81/image-20241206150958391.png" alt="image-20241206150958391" style="zoom:67%;" />

这时线程获得了锁，可以执行同步代码块，当该线程第二次到达同步代码块时会判断此时持有线程是否还是自己，JVM通过 account 对象的 MarkWord 判断，当前线程ID还在，说明持有这个对象锁，就可以继续进入临界区工作，由于之前没有释放锁，这里就不用重新加锁，如果自始至终使用锁的线程只有1个，很明显偏向锁几乎没有开销，性能极高。



#### 结论：

JVM不用和操作系统协商设置 Mutex 争取内核，他只需要记录下线程ID就标识自己获得了当前锁，不用操作系统介入。

