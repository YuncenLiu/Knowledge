## 1、虚拟机

### 1.1、java 虚拟机原理

​		所谓虚拟机，就是一台虚拟的机器。它是一款软件，用来执行一系列虚拟计算机指令，大体上虚拟机可以分为 虚拟计算机 和 程序计算机，大名鼎鼎的  Visual Box、VMare 就属于虚拟机，他们完全是对物理计算机的仿真提供了一个可以完整操作系统的软件平台。程序虚拟机典型代表就是  java 虚拟机，它专门为执行单个计算机程序而设计，在java虚拟机执行的指令我们成为 java 字节码指令。无论是系统 虚拟机 还是 程序虚拟机，在上面运行的软件被限制于虚拟机提供的资源中。java发展至今，出现过很多虚拟机，最初 sun 使用一款 classic 的java 虚拟机，到现在引用最广泛的是 HotSpot 虚拟机，除了 Sun 以外，还有 BEA JRockit，目前 JRockit 好 HotSpot 都被 Oralce 收入旗下，大有整合的趋势

#### 1.1.1、VMare 三种模式

桥接模式：网段都是一个网段，IP不一致

hostonly：只能和本地 ping 通，虚拟化出的节点，不能访问外网，只能和虚拟化出来的节点相互链接

NAT：网络转换，共享主机IP地址，

### 1.2、Java虚拟机结构

1. 类加载子系统：负责从文件系统和网络中加载 Clas6s 信息，加载的信息存放在一块为方法区的内存空间
2. 方法区：就是存放类的信息、常量信息、常量池信息、包括字符串字面量和数字常量等。
3. ==java堆==：在java虚拟机启动的时候建立java堆，它是 java 程序最主要的内存工作区域，几乎所有的对象实例都存放在 java 堆中，堆空间是所有线程共享的
4. 直接内存：java的NIO库运行java程序使用直接内存，从而提高性能，通过常量内存速度会优于java堆。读写频繁的场合可能会考虑使用
5. java栈：每个虚拟机线程都有一个私有的栈，一个线程的 java 栈在线程创建的时候被创建，java 栈中保存着局部变量、方法参数、同时 java 的方法调用、返回值等。
6. 本地方法栈：和java栈非常类似，最大不同为本地方法栈用于本地方法调用。java虚拟机运行java直接调用本地方法（通常使用 C 编写）
7. ==垃圾收集系统==：是java 的核心，也是必须可少的，java有一套自己进行垃圾清理的机制，开发人员无需手工清理，我们稍后详细说明。
8. PC 寄存器：也是每个线程私有的空间，java 虚拟机会为每个线程创建  PC 寄存器，在任意时刻，一个 java 线程总是在执行一个方法，这个方法被称为当前方法，如果当前方法不是本地方法，PC 寄存器就会执行当前正在被执行的指令，如果是本地方法，则PC 寄存器值为 Underfined ，寄存器存放当前执行环境指针、程序计算器、操作栈指针、计算的变量指针等信息。
9. ==执行引擎==：虚拟机最核心的主键就是执行引擎了，它负责执行虚拟机的字节码。一般用户进行编译成机器码后执行

## 2、堆、栈、方法区

+ 堆解决的是数据存储问题，既数据怎么放、放哪里，
+ 栈解决程序运行问题、既程序如何执行，或者说如何处理数据
+ 方法区则是辅助堆栈的一快永久区（Perm），解决堆栈信息的产生，是先决条件

我们创建新的对象：User：那么 User 类的一些信息（类信息、静态信息都存于方法区中）

而User类被实例出来之后，被存储到 java 堆中，一块内存空间，当我们去使用的时候，都是使用 User 对象的引用，形如 User user = new User()，这里的 user 就是存放 java 栈中的，即User 真实对象的一个引用 

![image-20200803124022636](images/%E5%A0%86%E6%A0%88%E6%96%B9%E6%B3%95%E5%8C%BA.png)

### 2.1、java堆详解

java堆是和 java 程序关系最密切的内存空间，几乎所有的对象都会存入到其中，并且 java 堆完全是自动管理的，通过垃圾回收机制，垃圾对象会自动清理，不需要释放

根据垃圾回收机制不同，java 堆有可能拥有不同的结构，最为常见的就是将整个 java 堆分为新生代和老年代。其中新生代存放新生的对象或年龄不大的对象，老年代则存放老年对象。新生代分为 eden 区、s0 区、s1 区，s0 和 s1 也被称为 from 和 to 区域，他们是两块大小相等并且可以互换身份的空间，绝大多数情况下，对象首先分配在 eden 区，在一次新生代回收后，如果对象还存活，则会进入 s0 或者 s1 区，之后每经过一次新生代回收，如果对象存放则它的年龄就会 +1 ，当对象达到一定的年龄后，则进入老年代。

eden区  》  s0  》   s1  》  tenured区
|           新生代               |     老年代    |

### 2.2、Java栈

java 栈是一块线程私有的内存空间，一个栈，一般由三部分组成：==局部变量、操作数栈、帧数据区==

局部变量表：用于报错函数的参数以及局部变量

操作数栈：主要保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

帧数据区：除了局部变量表和操作数栈以外，栈还需要一些数据来支持常量池的解析，这里帧数据区访问常量池的指针，方便程序访问常量池，另外，当函数返回或者出现异常时，虚拟机必须有一个异常处理表，方便发送异常的时候找到异常的代码，因此异常处理表也是帧数据区的一部分。  

> 操作数栈是操作数据的，局部变量表和帧数据区用来抛异常的 

### 2.3、方法区

java 方法区和堆一样，方法区是一块所有线程共享的内存区域，它保存系统的类信息，比如类字段、方法、常量池等。方法区的大小决定了系统可以保存多少个类，如果系统定义的类太多了，导致方法区溢出。虚拟机同样会抛出内存溢出错误。方法区可以理解为永存区（Perm）



## 3、虚拟机参数 [JVM参数](https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html)



​		虚拟机运行的过程中，如果可以跟踪系统的运行状态，那么对于问题的故障排除会有定的帮助，对此，虚拟机提供了一些跟踪系统状态的参数，使用给定的参数执行 java 程序，就可以在系统运行时打印相关日志，用于分析实际问题。我们进行虚拟机参数配置，其实主要就是围绕着堆、栈、方法进行配置 

### 3.1、堆分配参数（一）

+ -XX：+printGC 使用这个参数，虚拟机启动后，只要遇到 GC 就会的打印日志

     > `+`  表示启用    `-` 表示禁用

+ -XX：+UserSerialGC 配置串行回收器

+ -XX：+PrintGCDetails 可以查看详细信息，包括各个区的情况

+ -Xms：设置 java 程序启动时间初始堆大小

+ -Xmx：设置java 程序能获得的最大堆大小

+ -Xmx20m  -Xms5m -XX：+PrintConmmandLineFlags：可以将隐式或者显示传给虚拟机的参数输出

在实际工作中，我们可以直接将初始的堆大小设置相等，这样的好处是可以减少程序运行时的垃圾回收次数，从而提高性能

### 3.2、堆内存参数（二）

新生代的配置

+ -Xmn：可以设置新生代的大小，设置一个比较大的新生代会减少老年代的大小，这个参数对系统性能以及GC行为有很大影响，新生代大小一般会设置整个堆空间的 1/3 到 1/4 左右
+ -XX：SurvivoRatio：用来设置新生代中 eden 空间和 from / to 空间的比例。==含义： -XX：SurvivorRatio=eden / from = eden / to==

不同的堆分布情况，对系统执行会产生一定影响，在实际工作中，应该根据系统的特点做出合理的配置，基本策略：尽可能将对象预留在新生代，减少老年代的 GC 次数。

除了可以设置新生代的绝对大小（-Xmn），还可以使用（-XX：NewRatio）设置新生代和老年代的比例：-XX：NewRation = 老年代 / 新生代

### 3.3、堆溢出处理

在 java 程序的运行过程中，如果堆空间不足，则会抛出内存溢出错误（Out Of Menory）OOM，一旦这类问题发生在生产环境，可能引起严重的业务中断，java虚拟机提供了 -XX：+HeapDumpOnOutOfMemoryError，使用该参数可以在内存溢出时导出整个堆信息，与之配合使用的还有参数

-XX：HeapDumpPath，可以设置导出堆的存放路径

### 3.4、栈配置

Java 虚拟机提供了参数  -Xss 来指定线程的最大栈空间，整个参数也直接决定了函数可调用的最大深度。

### 3.5、方法区

和java堆一样，方法区是一块所有线程共享的内存区域，它用于保存系统的类信息，方法区（永久区）可以保存多少信息可以对其进行配置，在默认情况下 

-XX：MaxPermSize 为  ==64MB==  ，如果系统运行时生产大量的类，就需要设置一个相对合适的方法区，以免出现永久内存溢出问题

-XX：PermSize=64MB  -XX：MaxPermSize=64MB

### 3.6、直接内存配置

直接内存也是 java 程序中非常重要的组成部分，特别是广泛用于 NIO 中，直接跳过了java 堆，使java程序可以直接访问原生堆空间，因此在一定程度上加快了内存空间访问速度。但是说直接内存一定就可以提高内存访问速度也不见得，具体情况具体分析

相关配置参数： 

-XX：MaxDirectMemorySize，如果不设置默认值就为最大堆空间，既-Xmx。直接内存使用达到上限，就会触发垃圾回收器，如果不能有效的释放空间，也会引起系统的 OOM

## 4、垃圾回收概念、算法

引入计数法、标记压缩法、负责算法、分代、分区思想 

==引用计数法==： 这是一个比较古老而经典的垃圾收集算法，其核心就是在对象被其所时计算器加1，当而引用失效时候则减1，但是这种方式有非常严重的问题：无法处理循环引用的情况，还有就是每次进行加减操作比较浪费系统性能。

==标记清除法==：就是分为标记和清除两个阶段进行处理内存中的对象，当然这种方式也是非常大的弊端，就是空间碎片问题，垃圾回收后的空间不是连续的，*不连续的内存空间的工作效率要低于连续的内存空间*

==复制算法==：其核心思想就是将内存空间分为两块，每次只使用其中的一块，在垃圾回收前，将正在使用的内存中的存留对象复制到未被使用的内存块中，之后去清理之前正在使用的内存块中所有的对象，反复去交换两个内存角色，完成垃圾收集。（java新生代和 from to 空间就是使用的这个算法）

==标记压缩清除法==：标记压缩在标记清除之上做了优化，把存活的对象压缩到内存一端，而后进行垃圾清理。（java 中老年代使用的就是标记压缩法）

==分代算法==：就是根据对象的特点把内存分为 N 块，而后根据每个内存的特点使用不同的算法。对于新生代和老年代来说，新生代回收频率很高，但是每次回收耗时都很短，而老年代回收频率较低，但是耗时会比较长，所以应该尽量减少老年代的 GC，

==分区算法==：其主要就是将整个内存分为 N 多个小的独立空间，每个小空间都可以独立使用，这样细粒度的控制一次回收多少个小空间和那些小空间，而不是对整个空间进行GC，从而提升性能，并减少 GC 的停留时间



垃圾回收时的停顿现象

垃圾回收器的任务是识别和回收垃圾对象进行内存清理，为了让垃圾回收器可以高效的执行，大部分情况下，会要求系统进入一个停顿的状态。停顿的目的是终止所有应用线程，只是这样系统才不会有新的垃圾产生，同时停顿保证了系统状态在某一瞬间的一致性，也有益于更好底标记垃圾对象。因此在垃圾回收时，都会产生应用程序的停顿

### 4.1 对象如何进入老年代

一般而言对象首次创建会被放置在新生代的 eden 区，如果没有 GC 介入，则对象不会离开 eden 区，那么 eden 区的对象如何进入老年代呢？一般来讲，只要对象的年龄达到一定大小，就会自动离开 新生代进入老年代，对象年龄是由对象经历数次 GC 决定的，在新生代每次  GC 之后如果对象没有被回收则年龄加1，虚拟机提供了一个参数来控制新生代对象的最大年龄，当超过这个年龄范围就会晋升老年代

==-XX：MaxTenuringThreshold==，默认情况下为 15秒



总结：根据设置 MaxTenuringThreshold 参数，可以指定新生代对象经过多次回收后进入老年代。另外，大对象（新生代 eden 区无法装入时，也会直接进入老年代）。JVM里有个参数可以设置对象的大小超过在指定的大小之后，直接晋升老年代

==-XX：PretenureSizeThreshold==



总结：使用 PretenureSizeThreshold 可以进行指定进入老年代的对象大小，但是要注意 ==TLAB== 区域优先分配空间 

### 4.2、TLAB

TLAB 全称是 Thread Local Allocation Buffer 即线程本地分配缓存，从名字上看是一个线程专用的内存分配区域，是为了加速对象分批而生的。每一个线程都会产生一个 TLAB，该现场独享的工作区域，java虚拟机使用这种 TLAB 区来避免多线程冲突问题，提高了对象分配的效率。TLAB 空间一般不会太大，当大对象无法在 TLAB 分配时，则会直接分配到堆上。

-XX：+UseTLAB  使用 TLAB，默认开启

-XX：+TLABSize  设置 TLAB 大小

-XX：TLABRefillWasteFraction 设置维护进入 TLAB 空间的单个对象大小 他是一个比例值，默认为 64，即如果对象大于整个空间的 1/64，则在堆创建对象。

-XX：+PrintTLAB 查看TLAB 信息

-XX：ResizeTLAB 自调整 TLABReFillWasteFraction 阀值



-XX：-DoEscapeAnalysis：逃逸分析参数，默认开启      关闭的话，会降低 JVM，但是看不到响应参数

### 4.3、对象创建流程

尝试栈上分配  --》   尝试 TLAB 分配 --》 是否满足进入老年代  --》  进入eden  

![image-20200804163121126](images/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.png)