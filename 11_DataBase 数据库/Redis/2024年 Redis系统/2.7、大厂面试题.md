###  LRU 和 LFU 的区别是什么

LRU 策略基于使用的时间顺序来替换数据。它的基本思想是将最久未被使用的数据从缓存中移除

- **链表**：维护一个链表，最近访问的元素移动到链表的头部，最久未访问的元素在链表的尾部。
- **哈希表 + 双向链表**：结合哈希表和双向链表来实现快速的访问和更新操作。

 **优点**

- 简单易理解，适用于大多数情况下的缓存需求。
- 可以有效地捕获最近的使用模式。

**缺点**

- 对于具有长期存储需求的应用可能不够有效，因为它只关注最近使用的模式。



LFU 策略基于数据的使用频率来替换数据。它的基本思想是移除访问频率最低的数据。

- **计数器**：为每个缓存项维护一个访问计数器，每次访问时更新计数器。根据计数器的值来决定替换的对象。
- **堆**：使用堆数据结构来维护缓存项的频率。

 **优点**

- 更适合处理具有频繁访问模式的缓存需求。
- 可以有效地缓存那些被频繁访问的对象，而不是最近使用的对象。

 **缺点**

- 实现较复杂，需要额外的空间和时间来跟踪访问频率。
- 对于访问模式变化较快的情况可能不如 LRU 灵活。



- **LRU**：替换最久未被访问的缓存项，适用于大多数缓存需求，简单易实现。
- **LFU**：替换访问频率最低的缓存项，适用于频繁访问模式的场景，但实现更复杂。



### Redis默认多少内存可用

如果不设置内存大小，或者最大内存大小，默认为0，在64位操作系统下不限制内存大小（物理机上限），在32位操作系统下最多使用 3G

+ 0 的话，就是和服务器争内存
+ 默认一般都是 3/4  
+ 假设设置为 100M `maxmemory 1024b*1024m*100`，还可以通过修改 `redis.conf` 文件
+ 查看多少内存可用 `info memory`

Redis 达到上限内存，redis报错 `(error) OOM command not allowed when used memory > 'maxmemory'`

如果没有自动过期策略，就容易导致 内存被打爆。所以引发 内存过期策略





### Redis过期删除策略

当一个 `key` 的 `ttl` 到期，Redis 不会立刻删除这个 key，而是采用过期删除策略

1. 立即删除：对 CPU 不友好，用处理器换时间性能，（拿时间换空间）

2. 惰性删除：对 Memory 不友好，用存储空间换取处理器性能 `lazyfree-lazy-eviction=yes` 默认 `no`

	```sh
	192.168.58.10:6372> config get lazyfree-lazy-eviction
	lazyfree-lazy-eviction
	no
	```

3. 定期删除，会限制删除执行时间和频率来减少删除对 CPU 时间的影响

	1. 没隔一段时间，进行抽查，如果只采用定期抽查的话，就会导致总有key被抽查到，会导致大量key没有被删除
	2. 所以引出 Redis 缓存淘汰策略



### Redis缓存淘汰策略

配置文件搜索 `MEMORY MANAGEMENT`

![image-20240815140822457](images/2.7%E3%80%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/image-20240815140822457.png)

两个维度：

1. 过期键中筛选
2. 所有键中筛选

四个方面：

1.  LRU
2. LFU
3. Random
4. TTL

推荐使用：

1. 在所有key都最近经常使用，选择 allkey-lru，如果不确定哪种策略就用这种
2. 如果所有key访问频率都差不，用 allkeys-random
3. 对数据足够了解的话，为 key 指定 hint，可以选择 volatile-ttl 

