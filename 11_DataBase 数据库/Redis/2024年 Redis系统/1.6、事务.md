
可以一次执行多个命令，本质是一组命令的集合，一个事务中的所有命令都会序列化，**按顺序地串行化执行而不会被其他命令插入，不许加塞**

| 1.单独的隔离操作   | Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的 |
| ----------- | ---------------------------------------------------------------------------- |
| 2.没有隔离级别的概念 | 因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了                   |
| 3.不保证原子性    | Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力          |
| 4.排它性       | Redis会保证一个事务内的命令依次执行，而不会被其它命令插入                                              |
|             |                                                                              |

#### 正常执行

开启事务 `multi`  提交事务 `exec`

#### 放弃事务

开启事务 `multi`  回滚事务 `discard`

#### 全体连坐

1. 开启事务 `multi`
2. 先正常写入，然后再乱写
3. 最后 `exec` 提交，redis 发现你乱写，全部给你回滚了

#### 怨头债主

1. 开启事务 `multi`
2. 先正常写入，不乱写，就是无意写错了，比如 `incr email` ，此时 redis 并不知道我写错了。
3. 最后 `exec` 提交，Redis 发现你执行失败，此时仅仅这个命令失败。

#### watch监控

概念有点像：乐观锁策略 -> CAS

![](./images/Pasted%20image%2020240730230838.png)

#### unwatch放弃监控

已知有其他客户端修改了被监控值，执行 unwatch 放弃监控，再开启 multi 修改值，正常提交。